# python 核心编程(第三版)2.8节作业

## 2-1 套接字。

>**面向连接的套接字和无连接套接字之间的区别是什么？**

即TCP 与UDP 。
TCP连接会进行握手，并确保双方能准确收到。

UDP不进行握手，直接发送数据，没有确认对方是否收到。

## 2-3 套接字。

>**TCP和UDP中，哪种类型的服务器接受连接，并将他们转换到独立的套接字进行客户端通信？**

TCP会接受连接，并开通新的SOCKET进行数据传输。

## 2-4 客户端。

**更新TCP（tsTclnt.py)和UDP(tsUclnt.py)客户端，以使得服务器名称无需硬编码到应用程序中。此外，应该允许用户指定主机名和端口号，且如果二者中任何一个或者全部参数丢失，那么应该使用默认值。
**
### tsTclnt.py

```python
#!/usr/bin/env python3

from socket import *
deHOST = '10.5.31.28'
dePORT = 21567
BUFSIZ = 1024

HOST = input('HOST>')
PORT = input('PORT>')
if not HOST or not PORT:
    HOST=deHOST
    PORT = dePORT

ADDR = (HOST, PORT)
tcpCliSock = socket(AF_INET, SOCK_STREAM)
tcpCliSock.connect(ADDR)

while True:
    data = input('> ')
    if not data:
        break
    tcpCliSock.send(bytes(data, 'utf-8'))
    data = tcpCliSock.recv(BUFSIZ)
    if not data:
        break
    print(data.decode('utf-8'))

tcpCliSock.close()

```

### tsUclnt.py

```python
#!/usr/bin/env python3

from socket import *

deHOST = '10.5.31.28'
dePORT = 21567
BUFSIZ = 1024
HOST = input('HOST>')
PORT = input('PORT>')
if not HOST or not PORT:
    HOST=deHOST
    PORT = dePORT


ADDR = (HOST, PORT)

udpCliSock = socket(AF_INET, SOCK_DGRAM)

while True:
    data = input('> ')
    if not data:
        break
    udpCliSock.sendto(bytes(data,'utf-8'), ADDR)
    data, ADDR = udpCliSock.recvfrom(BUFSIZ)
    if not data:
        break
    print(data.decode('utf-8'))

udpCliSock.close()


```

## 2-5 网络互联和套接字

>**实现python库参考文档中关于socket模块中的TCP客户端/服务器程序示例，并使其能够正常工作。首先运行服务器，然后启动客户端。也可以在http://docs.python.org/library/socket#example 网址中找到在线源码。**
>
>**如果你觉得示例中服务器的功能太单调，那么可以更新服务器代码，以使它具有更多功能，令其能够识别以下命令。**
>
>**date** 服务器将返回其当前日期/时间戳，即time.ctime()
>
>**os** 获取操作系统信息(os.name)
>
>**ls** 列数当前目录文件清单(提示：os.listdir()列出一个目录，os.curdir是当前目录)。
>选做题：接受ls dir命令，返回dir目录中的文件清单。
>
>**你不需要一个网络来完成这个任务，因为你的计算及可以与自己通信。请注意，在服务器退出之后，在再次运行它之间必须清除它的绑定。否则，可能会遇到“端口已绑定”的错误提示。此外，操作系统通常会在5分钟内清除绑定，所以请耐心等待。**

### python docs :

> 以下是 4 个使用 TCP/IP 协议的最小示例程序：一台服务器，它将收到的所有数据原样返回（仅服务于一个客户端），还有一个使用该服务器的客户端。注意，服务器必须按序执行 socket(), bind(), listen(), accept() （可能需要重复执行 accept() 以服务多个客户端），而客户端仅需要按序执行 socket(), connect()。还须注意，服务器不在侦听套接字上发送 sendall()/recv()，而是在 accept() 返回的新套接字上发送。
>
>前两个示例仅支持 IPv4。
>```python
># Echo server program
>import socket
>
>HOST = ''                 # Symbolic name meaning all available interfaces
>PORT = 50007              # Arbitrary non-privileged port
>with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
>    s.bind((HOST, PORT))
>    s.listen(1)
>    conn, addr = s.accept()
>    with conn:
>        print('Connected by', addr)
>        while True:
>            data = conn.recv(1024)
>            if not data: break
>            conn.sendall(data)
>```
>```python
># Echo client program
>import socket
>
>HOST = 'daring.cwi.nl'    # The remote host
>PORT = 50007              # The same port as used by the server
>with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
>    s.connect((HOST, PORT))
>    s.sendall(b'Hello, world')
>    data = s.recv(1024)
>print('Received', repr(data))
>```
>
>下两个例子与上两个很像，但是同时支持 IPv4 和 IPv6。 服务端将监听第一个可用的地址族（它本应同时监听两个）。 在大多数支持 IPv6 的系统上，IPv6 将有优先权并且服务端可能不会接受 IPv4 流量。 客户端将尝试连接到作为名称解析结果被返回的所有地址，并将流量发送给连接成功的第一个地址。
>
>```python
># Echo server program
>import socket
>import sys
>
>HOST = None               # Symbolic name meaning all available interfaces
>PORT = 50007              # Arbitrary non-privileged port
>s = None
>for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC,
>                              socket.SOCK_STREAM, 0, socket.AI_PASSIVE):
>    af, socktype, proto, canonname, sa = res
>    try:
>        s = socket.socket(af, socktype, proto)
>    except OSError as msg:
>        s = None
>        continue
>    try:
>        s.bind(sa)
>        s.listen(1)
>    except OSError as msg:
>        s.close()
>        s = None
>        continue
>    break
>if s is None:
>    print('could not open socket')
>    sys.exit(1)
>conn, addr = s.accept()
>with conn:
>    print('Connected by', addr)
>    while True:
>        data = conn.recv(1024)
>        if not data: break
>        conn.send(data)
>```
>
>```python
># Echo client program
>import socket
>import sys
>
>HOST = 'daring.cwi.nl'    # The remote host
>PORT = 50007              # The same port as used by the server
>s = None
>for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC, socket.SOCK_STREAM):
>    af, socktype, proto, canonname, sa = res
>    try:
>        s = socket.socket(af, socktype, proto)
>    except OSError as msg:
>        s = None
>        continue
>    try:
>        s.connect(sa)
>    except OSError as msg:
>        s.close()
>        s = None
>        continue
>    break
>if s is None:
>    print('could not open socket')
>    sys.exit(1)
>with s:
>    s.sendall(b'Hello, world')
>    data = s.recv(1024)
>print('Received', repr(data))
>```
